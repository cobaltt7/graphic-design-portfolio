"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const ast_utils_1 = require("../utils/ast-utils");
const type_tracker_1 = require("../utils/type-tracker");
const replacements_utils_1 = require("../utils/replacements-utils");
const regexp_ast_analysis_1 = require("regexp-ast-analysis");
const regexpp_1 = require("regexpp");
class CapturingData {
    constructor(regexpContext) {
        this.unused = new Set();
        this.unusedNames = new Map();
        this.indexToCapturingGroup = new Map();
        this.countOfCapturingGroup = 0;
        this.state = {
            used: false,
            track: true,
        };
        this.regexpContext = regexpContext;
    }
    getUnused() {
        const unusedCapturingGroups = new Set(this.unused);
        const unusedNames = new Set();
        for (const cgNodes of this.unusedNames.values()) {
            for (const cgNode of cgNodes) {
                if (!unusedCapturingGroups.has(cgNode)) {
                    unusedNames.add(cgNode);
                }
            }
        }
        return {
            unusedCapturingGroups,
            unusedNames,
        };
    }
    usedIndex(ref) {
        const cgNode = this.indexToCapturingGroup.get(ref);
        if (cgNode) {
            this.unused.delete(cgNode);
        }
    }
    usedName(ref) {
        const cgNodes = this.unusedNames.get(ref);
        if (cgNodes) {
            this.unusedNames.delete(ref);
            for (const cgNode of cgNodes) {
                this.unused.delete(cgNode);
            }
        }
    }
    usedAllNames() {
        for (const cgNodes of this.unusedNames.values()) {
            for (const cgNode of cgNodes) {
                this.unused.delete(cgNode);
            }
        }
        this.unusedNames.clear();
    }
    usedAllUnnamed() {
        this.unused.clear();
    }
    isAllUsed() {
        return !this.unused.size && !this.unusedNames.size;
    }
    markAsUsed() {
        this.state.used = true;
    }
    markAsCannotTrack() {
        this.state.track = false;
    }
    isNeedReport() {
        return this.state.used && this.state.track && !this.isAllUsed();
    }
    visitor() {
        return {
            onCapturingGroupEnter: (cgNode) => {
                this.countOfCapturingGroup++;
                if (!cgNode.references.length) {
                    this.unused.add(cgNode);
                    this.indexToCapturingGroup.set(this.countOfCapturingGroup, cgNode);
                }
                else if (cgNode.references.some((ref) => typeof ref.ref === "string")) {
                    return;
                }
                if (cgNode.name) {
                    const array = this.unusedNames.get(cgNode.name);
                    if (array) {
                        array.push(cgNode);
                    }
                    else {
                        this.unusedNames.set(cgNode.name, [cgNode]);
                    }
                }
            },
        };
    }
}
function getCapturingGroupIdentifier(group) {
    if (group.name) {
        return `'${group.name}'`;
    }
    return `number ${regexp_ast_analysis_1.getCapturingGroupNumber(group)}`;
}
function getAllCapturingGroups(pattern) {
    const groups = [];
    regexpp_1.visitRegExpAST(pattern, {
        onCapturingGroupEnter(group) {
            groups.push(group);
        },
    });
    groups.sort((a, b) => a.start - b.start);
    return groups;
}
exports.default = utils_1.createRule("no-unused-capturing-group", {
    meta: {
        docs: {
            description: "disallow unused capturing group",
            category: "Best Practices",
            recommended: true,
        },
        fixable: "code",
        schema: [
            {
                type: "object",
                properties: {
                    fixable: { type: "boolean" },
                },
                additionalProperties: false,
            },
        ],
        messages: {
            unusedCapturingGroup: "Capturing group {{identifier}} is defined but never used.",
            unusedName: "Capturing group {{identifier}} has a name, but its name is never used.",
            makeNonCapturing: "Making this a non-capturing group.",
            removeName: "Remove the unused name.",
        },
        type: "suggestion",
        hasSuggestions: true,
    },
    create(context) {
        var _a, _b;
        const fixable = (_b = (_a = context.options[0]) === null || _a === void 0 ? void 0 : _a.fixable) !== null && _b !== void 0 ? _b : false;
        const typeTracer = type_tracker_1.createTypeTracker(context);
        const capturingDataMap = new Map();
        function reportUnused(capturingData) {
            const { node, getRegexpLocation, fixReplaceNode, patternAst, } = capturingData.regexpContext;
            const { unusedCapturingGroups, unusedNames, } = capturingData.getUnused();
            const fixableGroups = new Set();
            for (const group of getAllCapturingGroups(patternAst).reverse()) {
                if (unusedCapturingGroups.has(group)) {
                    fixableGroups.add(group);
                }
                else {
                    break;
                }
            }
            for (const cgNode of unusedCapturingGroups) {
                const fix = fixableGroups.has(cgNode)
                    ? fixReplaceNode(cgNode, cgNode.raw.replace(/^\((?:\?<[^<>]+>)?/, "(?:"))
                    : null;
                context.report({
                    node,
                    loc: getRegexpLocation(cgNode),
                    messageId: "unusedCapturingGroup",
                    data: { identifier: getCapturingGroupIdentifier(cgNode) },
                    fix: fixable ? fix : null,
                    suggest: fix
                        ? [{ messageId: "makeNonCapturing", fix }]
                        : null,
                });
            }
            for (const cgNode of unusedNames) {
                const fix = fixReplaceNode(cgNode, cgNode.raw.replace(/^\(\?<[^<>]+>/, "("));
                context.report({
                    node,
                    loc: getRegexpLocation(cgNode),
                    messageId: "unusedName",
                    data: { identifier: getCapturingGroupIdentifier(cgNode) },
                    fix: fixable ? fix : null,
                    suggest: [{ messageId: "removeName", fix }],
                });
            }
        }
        function verifyForMatch(node) {
            const capturingData = capturingDataMap.get(node.arguments[0]);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            if (!typeTracer.isString(node.callee.object)) {
                capturingData.markAsCannotTrack();
                return;
            }
            if (capturingData.regexpContext.flags.global) {
                capturingData.markAsUsed();
            }
            else {
                capturingData.markAsUsed();
                verifyForExecResult(node, capturingData);
            }
        }
        function verifyForSearch(node) {
            const capturingData = capturingDataMap.get(node.arguments[0]);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            if (!typeTracer.isString(node.callee.object)) {
                capturingData.markAsCannotTrack();
                return;
            }
            capturingData.markAsUsed();
        }
        function verifyForTest(node) {
            const capturingData = capturingDataMap.get(node.callee.object);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            capturingData.markAsUsed();
        }
        function verifyForReplace(node) {
            const capturingData = capturingDataMap.get(node.arguments[0]);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            if (!typeTracer.isString(node.callee.object)) {
                capturingData.markAsCannotTrack();
                return;
            }
            const replacementNode = node.arguments[1];
            if (replacementNode.type === "FunctionExpression" ||
                replacementNode.type === "ArrowFunctionExpression") {
                capturingData.markAsUsed();
                verifyForReplaceFunction(replacementNode, capturingData);
            }
            else {
                const evaluated = ast_utils_1.getStaticValue(context, node.arguments[1]);
                if (!evaluated || typeof evaluated.value !== "string") {
                    capturingData.markAsCannotTrack();
                    return;
                }
                capturingData.markAsUsed();
                verifyForReplacePattern(evaluated.value, capturingData);
            }
        }
        function verifyForReplacePattern(replacementPattern, capturingData) {
            for (const replacement of replacements_utils_1.parseReplacementsForString(replacementPattern)) {
                if (replacement.type === "ReferenceElement") {
                    if (typeof replacement.ref === "number") {
                        capturingData.usedIndex(replacement.ref);
                    }
                    else {
                        capturingData.usedName(replacement.ref);
                    }
                }
            }
        }
        function verifyForReplaceFunction(replacementNode, capturingData) {
            for (let index = 0; index < replacementNode.params.length; index++) {
                const arg = replacementNode.params[index];
                if (arg.type === "RestElement") {
                    capturingData.markAsCannotTrack();
                    return;
                }
                if (index === 0) {
                    continue;
                }
                else if (index <= capturingData.countOfCapturingGroup) {
                    capturingData.usedIndex(index);
                }
                else if (capturingData.countOfCapturingGroup + 3 <= index) {
                    capturingData.usedAllNames();
                }
            }
        }
        function verifyForExec(node) {
            const capturingData = capturingDataMap.get(node.callee.object);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            capturingData.markAsUsed();
            verifyForExecResult(node, capturingData);
        }
        function verifyForExecResult(node, capturingData) {
            for (const ref of ast_utils_1.extractPropertyReferences(node, context)) {
                if (hasNameRef(ref)) {
                    if (ref.name === "groups") {
                        for (const namedRef of ref.extractPropertyReferences()) {
                            if (hasNameRef(namedRef)) {
                                capturingData.usedName(namedRef.name);
                            }
                            else {
                                capturingData.usedAllNames();
                            }
                        }
                    }
                    else {
                        capturingData.usedIndex(Number(ref.name));
                    }
                }
                else {
                    capturingData.markAsCannotTrack();
                    return;
                }
            }
        }
        function verifyForMatchAll(node) {
            const capturingData = capturingDataMap.get(node.arguments[0]);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            if (!typeTracer.isString(node.callee.object)) {
                capturingData.markAsCannotTrack();
                return;
            }
            capturingData.markAsUsed();
            for (const iterationRef of ast_utils_1.extractPropertyReferences(node, context)) {
                if (!iterationRef.extractPropertyReferences) {
                    capturingData.markAsCannotTrack();
                    return;
                }
                if (hasNameRef(iterationRef)) {
                    if (Number.isNaN(Number(iterationRef.name))) {
                        continue;
                    }
                }
                for (const ref of iterationRef.extractPropertyReferences()) {
                    if (hasNameRef(ref)) {
                        if (ref.name === "groups") {
                            for (const namedRef of ref.extractPropertyReferences()) {
                                if (hasNameRef(namedRef)) {
                                    capturingData.usedName(namedRef.name);
                                }
                                else {
                                    capturingData.usedAllNames();
                                }
                            }
                        }
                        else {
                            capturingData.usedIndex(Number(ref.name));
                        }
                    }
                    else {
                        capturingData.markAsCannotTrack();
                        return;
                    }
                }
            }
        }
        function verifyForSplit(node) {
            const capturingData = capturingDataMap.get(node.arguments[0]);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            if (!typeTracer.isString(node.callee.object)) {
                capturingData.markAsCannotTrack();
                return;
            }
            capturingData.markAsUsed();
            capturingData.usedAllUnnamed();
        }
        function createVisitor(regexpContext) {
            const { regexpNode } = regexpContext;
            const capturingData = new CapturingData(regexpContext);
            capturingDataMap.set(regexpNode, capturingData);
            for (const ref of ast_utils_1.extractExpressionReferences(regexpNode, context)) {
                if (ref.type === "argument" || ref.type === "member") {
                    capturingDataMap.set(ref.node, capturingData);
                }
                else {
                    capturingData.markAsCannotTrack();
                }
            }
            return capturingData.visitor();
        }
        return utils_1.compositingVisitors(utils_1.defineRegexpVisitor(context, {
            createVisitor,
        }), {
            "Program:exit"() {
                for (const capturingData of new Set(capturingDataMap.values())) {
                    if (capturingData.isNeedReport()) {
                        reportUnused(capturingData);
                    }
                }
            },
            "CallExpression:exit"(node) {
                if (!ast_utils_1.isKnownMethodCall(node, {
                    match: 1,
                    test: 1,
                    search: 1,
                    replace: 2,
                    replaceAll: 2,
                    matchAll: 1,
                    exec: 1,
                    split: 1,
                })) {
                    return;
                }
                if (node.callee.property.name === "match") {
                    verifyForMatch(node);
                }
                else if (node.callee.property.name === "test") {
                    verifyForTest(node);
                }
                else if (node.callee.property.name === "search") {
                    verifyForSearch(node);
                }
                else if (node.callee.property.name === "replace" ||
                    node.callee.property.name === "replaceAll") {
                    verifyForReplace(node);
                }
                else if (node.callee.property.name === "exec") {
                    verifyForExec(node);
                }
                else if (node.callee.property.name === "matchAll") {
                    verifyForMatchAll(node);
                }
                else if (node.callee.property.name === "split") {
                    verifyForSplit(node);
                }
            },
        });
    },
});
function hasNameRef(ref) {
    return ref.type === "destructuring" || ref.type === "member";
}
