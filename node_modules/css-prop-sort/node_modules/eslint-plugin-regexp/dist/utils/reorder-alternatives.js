"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDeterminismEqClasses = exports.canReorder = void 0;
const refa_1 = require("refa");
const regexp_ast_analysis_1 = require("regexp-ast-analysis");
function canReorder(alternatives, context, options = {}) {
    const { ignoreCapturingGroups = false, matchingDirection } = options;
    const target = asSet(alternatives);
    if (target.size < 2) {
        return true;
    }
    const slice = getAlternativesSlice(target);
    const dir = matchingDirection !== null && matchingDirection !== void 0 ? matchingDirection : regexp_ast_analysis_1.getMatchingDirection(slice[0]);
    const eqClasses = dir === "unknown"
        ? getDirectionIndependedDeterminismEqClasses(slice, context)
        : getDeterminismEqClasses(slice, dir, context);
    if (!ignoreCapturingGroups &&
        !canReorderCapturingGroups(target, slice, eqClasses)) {
        return false;
    }
    return eqClasses.every((eq) => {
        if (eq.length < 2) {
            return true;
        }
        if (eq.every((a) => !target.has(a))) {
            return true;
        }
        return (canReorderBasedOnLength(eq) ||
            canReorderBasedOnConsumedChars(eq, context));
    });
}
exports.canReorder = canReorder;
function canReorderCapturingGroups(target, slice, eqClasses) {
    const containsCG = cachedFn(containsCapturingGroup);
    let targetCG = 0;
    let nonTargetCG = 0;
    for (const a of slice) {
        if (containsCG(a)) {
            if (target.has(a)) {
                targetCG++;
            }
            else {
                nonTargetCG++;
            }
        }
    }
    if (targetCG > 1 || (targetCG === 1 && nonTargetCG !== 0)) {
        return false;
    }
    if (nonTargetCG !== 0) {
        return eqClasses.every((eq) => {
            return (!eq.some(containsCapturingGroup) ||
                eq.every((a) => !target.has(a)));
        });
    }
    else if (targetCG !== 0) {
        return eqClasses.every((eq) => {
            return eq.length < 2 || !eq.some(containsCapturingGroup);
        });
    }
    return true;
}
function getDeterminismEqClasses(alternatives, dir, context) {
    if (dir === "unknown") {
        return getDirectionIndependedDeterminismEqClasses(alternatives, context);
    }
    return getDirectionalDeterminismEqClasses(alternatives, dir, context);
}
exports.getDeterminismEqClasses = getDeterminismEqClasses;
function getDirectionIndependedDeterminismEqClasses(alternatives, context) {
    const ltr = getDirectionalDeterminismEqClasses(alternatives, "ltr", context);
    const rtl = getDirectionalDeterminismEqClasses(alternatives, "rtl", context);
    const disjoint = mergeOverlappingSets(new Set([...ltr, ...rtl]), (s) => s);
    const result = [];
    for (const sets of disjoint) {
        const eq = new Set();
        for (const s of sets) {
            s.forEach((a) => eq.add(a));
        }
        result.push([...eq]);
    }
    return result;
}
function getDirectionalDeterminismEqClasses(alternatives, dir, context) {
    const getPrefixCharSets = cachedFn((a) => {
        const prefix = getTopLevelAlternativePrefix(a, dir, context);
        for (let i = prefix.length - 1; i >= 0; i--) {
            if (prefix[i].isAll) {
                prefix.pop();
            }
            else {
                break;
            }
        }
        return prefix;
    });
    const allCharSets = new Set();
    for (const a of alternatives) {
        getPrefixCharSets(a).forEach((cs) => allCharSets.add(cs));
    }
    const base = new refa_1.CharBase(allCharSets);
    const prefixes = [];
    for (const a of alternatives) {
        prefixes.push({
            characters: getPrefixCharSets(a).map((cs) => base.split(cs)),
            alternative: a,
        });
    }
    function subdivide(eqClass, index) {
        if (eqClass.size < 2) {
            return [[...eqClass]];
        }
        for (const prefix of eqClass) {
            if (index >= prefix.characters.length) {
                return [[...eqClass]];
            }
        }
        const disjointSets = mergeOverlappingSets(eqClass, (p) => p.characters[index]);
        const result = [];
        for (const set of disjointSets) {
            result.push(...subdivide(set, index + 1));
        }
        return result;
    }
    return subdivide(new Set(prefixes), 0).map((eq) => eq.map((p) => p.alternative));
}
function* mergeOverlappingSets(sets, getElements) {
    if (sets.size < 2) {
        yield sets;
        return;
    }
    const map = new Map();
    let disjoint = true;
    for (const s of sets) {
        for (const e of getElements(s)) {
            const entry = map.get(e);
            if (entry === undefined) {
                map.set(e, { type: "Set", set: new Set([s]) });
            }
            else if (entry.type === "Set") {
                entry.set.add(s);
                disjoint = false;
            }
        }
    }
    function resolve(key) {
        let e = key;
        for (;;) {
            const entry = map.get(e);
            if (entry && entry.type === "Ref") {
                e = entry.key;
            }
            else {
                return e;
            }
        }
    }
    if (!disjoint) {
        for (const s of sets) {
            const toMergeSet = new Set();
            for (const e of getElements(s)) {
                toMergeSet.add(resolve(e));
            }
            if (toMergeSet.size < 2) {
                continue;
            }
            const toMerge = [...toMergeSet];
            const intoKey = toMerge[0];
            const intoSet = map.get(intoKey);
            for (let i = 1; i < toMerge.length; i++) {
                const mergeKey = toMerge[i];
                const mergeSet = map.get(mergeKey);
                mergeSet.set.forEach((p) => intoSet.set.add(p));
                map.set(mergeKey, { type: "Ref", key: intoKey });
            }
        }
    }
    for (const value of map.values()) {
        if (value.type === "Set") {
            yield value.set;
        }
    }
}
function getTopLevelAlternativePrefix(alternative, dir, context) {
    const { prefix, complete } = getAlternativePrefix(alternative, dir, context);
    if (complete) {
        const last = dir === "ltr"
            ? alternative.elements[alternative.elements.length - 1]
            : alternative.elements[0];
        if (last) {
            const cs = regexp_ast_analysis_1.getFirstCharAfter(last, dir, context.flags).char;
            if (!cs.isEmpty) {
                prefix.push(cs);
            }
        }
    }
    return prefix;
}
function getAlternativePrefix(alternative, dir, context) {
    const prefix = [];
    const elements = dir === "ltr"
        ? alternative.elements
        : [...alternative.elements].reverse();
    let lastComplete = undefined;
    for (const e of elements) {
        if (regexp_ast_analysis_1.isZeroLength(e)) {
            continue;
        }
        let elementPrefix;
        switch (e.type) {
            case "Character":
            case "CharacterClass":
            case "CharacterSet":
                elementPrefix = getCharAlternativePrefix(e, dir, context);
                break;
            case "CapturingGroup":
            case "Group":
                elementPrefix = getGroupAlternativePrefix(e, dir, context);
                break;
            case "Quantifier":
                elementPrefix = getQuantifierAlternativePrefix(e, dir, context);
                break;
            default:
                elementPrefix = undefined;
        }
        if (elementPrefix) {
            prefix.push(...elementPrefix.prefix);
            if (!elementPrefix.complete) {
                return { prefix, complete: false };
            }
            lastComplete = e;
        }
        else {
            let cs;
            if (lastComplete === undefined) {
                const fcc = regexp_ast_analysis_1.getFirstConsumedChar(alternative, dir, context.flags);
                cs = fcc.empty ? fcc.char.union(fcc.look.char) : fcc.char;
            }
            else {
                cs = regexp_ast_analysis_1.getFirstCharAfter(lastComplete, dir, context.flags).char;
            }
            if (!cs.isEmpty) {
                prefix.push(cs);
            }
            return { prefix, complete: false };
        }
    }
    return { prefix, complete: true };
}
function getGroupAlternativePrefix(group, dir, context) {
    if (group.alternatives.length === 1) {
        return getAlternativePrefix(group.alternatives[0], dir, context);
    }
    return undefined;
}
function getCharAlternativePrefix(element, _dir, context) {
    const cs = context.toCharSet(element);
    if (cs.isEmpty) {
        return undefined;
    }
    return { prefix: [cs], complete: true };
}
function getQuantifierAlternativePrefix(quant, dir, context) {
    if (quant.min > 100) {
        return undefined;
    }
    if (quant.min < 1) {
        return undefined;
    }
    let inner;
    switch (quant.element.type) {
        case "CapturingGroup":
        case "Group":
            inner = getGroupAlternativePrefix(quant.element, dir, context);
            break;
        case "Character":
        case "CharacterClass":
        case "CharacterSet":
            inner = getCharAlternativePrefix(quant.element, dir, context);
            break;
        default:
            inner = undefined;
    }
    if (!inner) {
        return undefined;
    }
    if (!inner.complete || inner.prefix.length === 0) {
        return inner;
    }
    const prefix = [];
    for (let i = 0; i < quant.min; i++) {
        prefix.push(...inner.prefix);
    }
    if (quant.min === quant.max) {
        return { prefix, complete: true };
    }
    const after = regexp_ast_analysis_1.getFirstCharAfter(quant, dir, context.flags);
    prefix.push(prefix[0].union(after.char));
    return { prefix, complete: false };
}
function canReorderBasedOnLength(slice) {
    const lengthRange = regexp_ast_analysis_1.getLengthRange(slice);
    return Boolean(lengthRange && lengthRange.min === lengthRange.max);
}
function canReorderBasedOnConsumedChars(slice, context) {
    if (slice.some(regexp_ast_analysis_1.isPotentiallyZeroLength)) {
        return false;
    }
    const parent = slice[0].parent;
    if (parent.type === "Pattern" || parent.type === "Assertion") {
        return false;
    }
    const consumedChars = regexp_ast_analysis_1.Chars.empty(context.flags).union(...slice.map((a) => getConsumedChars(a, context)));
    return (regexp_ast_analysis_1.getFirstCharAfter(parent, "rtl", context.flags).char.isDisjointWith(consumedChars) &&
        regexp_ast_analysis_1.getFirstCharAfter(parent, "ltr", context.flags).char.isDisjointWith(consumedChars));
}
function getAlternativesSlice(set) {
    if (set.size <= 1) {
        return [...set];
    }
    let first;
    for (const item of set) {
        first = item;
        break;
    }
    if (!first) {
        throw new Error();
    }
    const parentAlternatives = first.parent.alternatives;
    let min = set.size;
    let max = 0;
    for (let i = 0; i < parentAlternatives.length; i++) {
        const a = parentAlternatives[i];
        if (set.has(a)) {
            min = Math.min(min, i);
            max = Math.max(max, i);
        }
    }
    return parentAlternatives.slice(min, max + 1);
}
function asSet(iter) {
    if (iter instanceof Set) {
        return iter;
    }
    return new Set(iter);
}
function getConsumedChars(element, context) {
    const sets = [];
    regexp_ast_analysis_1.hasSomeDescendant(element, (d) => {
        if (d.type === "Character" ||
            d.type === "CharacterClass" ||
            d.type === "CharacterSet") {
            sets.push(context.toCharSet(d));
        }
        else if (d.type === "Backreference" && !regexp_ast_analysis_1.isEmptyBackreference(d)) {
            sets.push(getConsumedChars(d.resolved, context));
        }
        return false;
    }, (d) => d.type !== "Assertion" && d.type !== "CharacterClass");
    return regexp_ast_analysis_1.Chars.empty(context.flags).union(...sets);
}
function containsCapturingGroup(node) {
    return regexp_ast_analysis_1.hasSomeDescendant(node, (d) => d.type === "CapturingGroup");
}
function cachedFn(fn) {
    function wrapper(value) {
        let cached = wrapper.cache.get(value);
        if (cached === undefined) {
            cached = fn(value);
            wrapper.cache.set(value, cached);
        }
        return cached;
    }
    wrapper.cache = new Map();
    return wrapper;
}
